/***************************************************************************************************
*
* 版权信息：版权所有 (c) 2015, 杭州海康威视数字技术股份有限公司, 保留所有权利
*
* 文件名称：dat_abc.c
* 摘    要：abc模块接口函数
*
* 当前版本：0.1.0
* 作    者：武晓阳
* 日    期：2015-05-19
* 备    注：创建并完成草案
***************************************************************************************************/
#include <string.h>
#include "hka_data_type.h"
#include "hka_defs.h"
#include "hka_core.h"
#include "ffg_lib.h"
#include "ffg_inside.h"



/***************************************************************************************************
* 功  能：获取库所需存储信息
* 参  数：*
*         ability   -I  能力集参数指针
*         mem_tab   -O  存储空间参数结构体
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_GetMemSize(HKAFFG_ABILITY *ability,
	HKA_MEM_TAB     mem_tab[HKA_MEM_TAB_NUM])
{
	HKA_STATUS   sts = HKA_STS_ERR;
	HKAFFG_INPUT *input = HKA_NULL;
	FFG_SPEC spec = { 0 };


	HKA_SZT      tmp_buf_size = 0;
	HKA_SZT      modu_status_size = 0;
	HKA_SZT      modu_work_size = 0;
	HKA_SZT      persist_size = 0;
	HKA_SZT      scratch_size = 0;

	HKA_MEM_TAB  mtab_tmp[HKA_MEM_TAB_NUM] = { 0 };   //对第一个结构体的第一个元素初始化为0
	HKA_MEM_TAB *mtab_persist = HKA_NULL;
	HKA_MEM_TAB *mtab_scratch = HKA_NULL;

	//参数检测
	HKA_CHECK_ERROR((HKA_NULL == ability) || (HKA_NULL == mem_tab), HKA_STS_ERR_NULL_PTR);
	
	sts = FFG_check_ability_param(ability);
	HKA_CHECK_ERROR((HKA_STS_OK != sts), sts);

	//初始化局部变量
	persist_size = 0;
	scratch_size = 0;
	mtab_persist = &mtab_tmp[HKA_MEM_TAB_PERSIST];
	mtab_scratch = &mtab_tmp[HKA_MEM_TAB_SCRATCH];

	//初始化临时 spec
	memset(&spec, 0, sizeof(FFG_SPEC));
	//memcpy(&(spec.ability), ability, sizeof(HKAFFG_ABILITY));

	
	//获取接口模块所需persist内存,本模块暂时不使用persist内存
	mtab_persist->size = HKA_MAX_MEM_SIZE; //虚拟分配足够大空间
	mtab_persist->alignment = HKA_MEM_ALIGN_128BYTE;
	mtab_persist->base = (HKA_VOID *)&spec;


	//获取接口模块所需scratch内存大小，多个处理模块需要共用的内存
	mtab_scratch->size = HKA_MAX_MEM_SIZE; //虚拟分配足够大空间
	mtab_scratch->alignment = HKA_MEM_ALIGN_128BYTE;
	mtab_scratch->base = (HKA_VOID *)&spec;

	//FFG_SPEC->HKAFFG_OUTPUT->GROUP_HEADER->buffer_size
	tmp_buf_size = sizeof(FFG_SPEC);
	tmp_buf_size = HKA_SIZE_ALIGN_128(tmp_buf_size);
	scratch_size += tmp_buf_size;

	tmp_buf_size = sizeof(HKAFFG_OUTPUT);
	tmp_buf_size = HKA_SIZE_ALIGN_128(tmp_buf_size);
	scratch_size += tmp_buf_size;

	tmp_buf_size = sizeof(GROUP_HEADER);
	tmp_buf_size = HKA_SIZE_ALIGN_128(tmp_buf_size);
	scratch_size += tmp_buf_size;

	tmp_buf_size = ability->read_array_size;
	tmp_buf_size = HKA_SIZE_ALIGN_128(tmp_buf_size);
	scratch_size += tmp_buf_size;

	
	//总大小检测
	HKA_CHECK_ERROR((persist_size + scratch_size) > HKA_MAX_MEM_SIZE, HKA_STS_ERR_OVER_MAX_MEM);

	mtab_persist = &mem_tab[HKA_MEM_TAB_PERSIST];
	mtab_persist->size = persist_size;
	mtab_persist->alignment = HKA_MEM_ALIGN_128BYTE;
	mtab_persist->base = HKA_NULL;

	mtab_scratch = &mem_tab[HKA_MEM_TAB_SCRATCH];
	mtab_scratch->size = scratch_size;
	mtab_scratch->alignment = HKA_MEM_ALIGN_128BYTE;
	mtab_scratch->base = HKA_NULL;

	return HKA_STS_OK;

}

/***************************************************************************************************
* 功  能：创建库实例
* 参  数：*
*         ability       -I   能力集参数指针
*         mem_tab       -I   存储空间参数结构体
*         handle        -O   库实例句柄
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Create(HKAFFG_ABILITY *ability,
	HKA_MEM_TAB     mem_tab[HKA_MEM_TAB_NUM],
	HKA_VOID      **handle)
{
	HKA_STATUS   sts = HKA_STS_ERR;
	FFG_SPEC    *spec = HKA_NULL;

	HKA_MEM_TAB  mtab_tmp[HKA_MEM_TAB_NUM] = { 0 };
	HKA_MEM_TAB *mtab_persist = HKA_NULL;
	HKA_MEM_TAB *mtab_scratch = HKA_NULL;

	HKA_U08     *left_persist_buf = HKA_NULL;
	HKA_U08     *left_scratch_buf = HKA_NULL;
	HKA_SZT      left_persist_size = 0;
	HKA_SZT      left_scratch_size = 0;
	HKA_SZT      tmp_buf_size = 0;

	//参数检测
	HKA_CHECK_ERROR((HKA_NULL == ability) || (HKA_NULL == mem_tab) || (HKA_NULL == handle),
		HKA_STS_ERR_NULL_PTR);

	//检查内存是否按128字节对齐
	sts = HKA_CheckMemTab(mem_tab, HKA_MEM_TAB_NUM, HKA_MEM_ALIGN_128BYTE);
	HKA_CHECK_ERROR(sts != HKA_STS_OK, sts);

	//检查配置参数是否在有效范围
	sts = FFG_check_ability_param(ability);
	HKA_CHECK_ERROR(sts != HKA_STS_OK, sts);


	//初始化
	mtab_persist = &mem_tab[HKA_MEM_TAB_PERSIST];
	mtab_persist->alignment = HKA_MEM_ALIGN_128BYTE;
	left_persist_size = mtab_persist->size;
	left_persist_buf = (HKA_U08 *)mtab_persist->base;

	mtab_scratch = &mem_tab[HKA_MEM_TAB_SCRATCH];
	mtab_scratch->alignment = HKA_MEM_ALIGN_128BYTE;
	left_scratch_size = mtab_scratch->size;
	left_scratch_buf = (HKA_U08 *)mtab_scratch->base;

	//解析persist内存,这里我没有使用



	//解析scratch内存,本模块仅使用scratch内存
	//分配spec
	tmp_buf_size = sizeof(FFG_SPEC);
	tmp_buf_size = HKA_SIZE_ALIGN_128(tmp_buf_size);
	HKA_CHECK_ERROR(left_scratch_size < tmp_buf_size, HKA_STS_ERR_MEM_LACK);
	spec = (FFG_SPEC *)(left_scratch_buf); //该结构体大小在alloc persist里面分配，不用扣除大小

	//初始化spec结构体参数
	memset(spec, 0, sizeof(FFG_SPEC));
	//memcpy(&spec->ability, ability, sizeof(HKAFFG_ABILITY));


	//分配接口模块所需scratch内存
	mtab_scratch = &mtab_tmp[HKA_MEM_TAB_SCRATCH];
	mtab_scratch->alignment = HKA_MEM_ALIGN_128BYTE;
	mtab_scratch->size = left_scratch_size;
	mtab_scratch->base = left_scratch_buf;

	sts = FFG_alloc_scratch_mem(spec, mtab_scratch, &tmp_buf_size);
	HKA_CHECK_ERROR(sts != HKA_STS_OK, sts);
	left_scratch_size -= tmp_buf_size;
	left_scratch_buf += tmp_buf_size;  

	//输出实例句柄
	*handle = (HKA_VOID *)spec;

	return HKA_STS_OK;


}


/***************************************************************************************************
* 功  能：算法库处理函数，找到组信息
* 参  数：*
*         handle         -I   库实例句柄
*         in_buf         -I   处理输入参数地址
*         in_size        -I   处理输入参数大小
*         out_size       -I   处理输出参数大小
*         out_buf        -O   处理输出参数地址
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Process(HKA_VOID *handle,
	HKA_VOID *in_buf,
	HKA_SZT   in_size,
	HKA_VOID *out_buf,
	HKA_SZT   out_size)
{
	HKA_STATUS status = HKA_STS_ERR;
	HKAFFG_OUTPUT *output = HKA_NULL;
	HKAFFG_INPUT *input = HKA_NULL;
	FFG_SPEC *spec = HKA_NULL;
	//参数初始化
	
	input = (HKAFFG_INPUT *)in_buf;
	output = (HKAFFG_OUTPUT *)out_buf;
	spec = (FFG_SPEC *)handle;

	//获得视频文件大小
	if (input->fp == NULL)
		return HKA_STS_ERR;

	fseek(input->fp, 0, SEEK_END);
	HKA_U32 file_size = ftell(input->fp);
	//15ms

	HKA_U32 slice_size = SLICE_SIZE;  //根据L1 cache 32KB的大小设置
	HKA_U32 slice_num = (file_size + slice_size - 1) / slice_size;

	HKA_U32 start_frame_pos = -1;
	HKA_U32 end_frame_pos = -1;

	HKA_U32 target_pos = -1;

	HKA_U32 start_frame_num = -1;
	HKA_U32 end_frame_num = -1;
	HKA_U32 cur_frame_num;

	//46ms

	if (file_size <= slice_size)
	{
		fseek(input->fp, 0, SEEK_END);
		fread(spec->buffer, file_size, 1, input->fp);
		status = HKAFFG_Process_Slice(spec->buffer, input->target_frame_num, file_size, &cur_frame_num, &target_pos);
		if (status == HKA_STS_OK)
		{
			output->res = (GROUP_HEADER *)(spec->buffer + target_pos);
			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//46ms

	//搜索原始文件的起始帧号
	HKA_S32 slice_start = 0;
	for (HKA_U32 i = 0; i < slice_num; i++)
	{
		if (i != 0)
		{
			slice_start = slice_size*i - 7;
		}
		fseek(input->fp, slice_start, SEEK_SET);                 //如果属于视频开头片段的话,从0开始切片段

		//当切割到最后一个slice时,最后一个slice中的数据可能小于slice_size的特殊处理, 避免搜索的时候出现越界
		if ((file_size - slice_start) < slice_size)
		{
			slice_size = file_size - slice_start;
		}

		fread(spec->buffer, slice_size, 1, input->fp);
		status = HKAFFG_Searching_Start_Group(spec->buffer, slice_size, &start_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *start_group_header = (GROUP_HEADER *)(spec->buffer + start_frame_pos);
			start_frame_num = start_group_header->frame_num;
			start_frame_pos = slice_start + start_frame_pos;
			break;
		}
	}
	//如果没有搜索到起始帧号,说明原始文件中没有完整帧信息,结束函数
	if ((start_frame_num <0x00001000) || (input->target_frame_num<start_frame_num))
		return HKA_STS_ERR;

	if (input->target_frame_num == start_frame_num)
	{
		output->res = (GROUP_HEADER *)(spec->buffer + start_frame_pos);

		return HKA_STS_OK;
	}

	//31
	/*******************************************************************************************************************/
	//搜索原始文件的结束帧号
	slice_start = slice_size;
	for (HKA_U32 i = 1; i <slice_num; i++)
	{

		if (i > 1)
		{
			slice_start = slice_size*i - 7;         //原来是-3，结果正确
		} 

		if (slice_start > file_size)
		{
			slice_size = file_size + slice_size - slice_start;
			slice_start = file_size;
		}
		fseek(input->fp, -slice_start, SEEK_END);

		fread(spec->buffer, slice_size, 1, input->fp);
		status = HKAFFG_Searching_End_Group(spec->buffer, slice_size, &end_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *end_group_header = (GROUP_HEADER *)(spec->buffer + end_frame_pos);
			end_frame_num = end_group_header->frame_num;
			end_frame_pos = file_size - slice_start + end_frame_pos;
			break;
		}
	}
	////////如果没有搜索到结束帧号,说明原始文件中没有完整帧信息,结束函数
	if ((end_frame_num <0x00001000) || (input->target_frame_num>end_frame_num))
		return HKA_STS_ERR;

	if (input->target_frame_num == end_frame_num)
	{
		output->res = (GROUP_HEADER *)(spec->buffer + start_frame_pos);

		return HKA_STS_OK;
	}


	if (end_frame_num == start_frame_num)
	{
		if (input->target_frame_num == start_frame_num)
		{
			output->res = (GROUP_HEADER *)(spec->buffer + start_frame_pos);

			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//109
	///**********************************************************************************************************************/
	////开始在进行slice级别的二分查找

	HKA_U32 start_frame_temp = start_frame_num;
	HKA_U32 end_frame_temp = end_frame_num;
	HKA_U32 mid_slice_pos;
	HKA_U32 mid_slice_pos1;

	mid_slice_pos = (end_frame_pos - start_frame_pos) / (end_frame_num - start_frame_num);
	mid_slice_pos = mid_slice_pos*(input->target_frame_num - start_frame_num) + start_frame_pos;

	
	HKA_U32 i = 0;
	while (1)
	{
		slice_size = SLICE_SIZE;

		fseek(input->fp, mid_slice_pos, SEEK_SET);
		if ((file_size - mid_slice_pos)<slice_size)
		{
			slice_size = file_size - mid_slice_pos;
		}
		fread(spec->buffer, slice_size, 1, input->fp);
		status = HKAFFG_Process_Slice(spec->buffer, input->target_frame_num, slice_size, &cur_frame_num, &target_pos);
		/*i++;
		printf("target_frame: %d,  times:%d\n", input->target_frame_num, i);*/
		//对片段内的搜索结果进行处理

		//说明帧号不存在
		if (status == HKA_STS_ERR)
		{
			return HKA_STS_ERR;
		}

		//帧号搜索成功
		if (status == HKA_STS_OK)
		{
			output->res = (GROUP_HEADER *)(spec->buffer + target_pos);
			return HKA_STS_OK;
		}
		//如果数据片段内不存在帧号信息
		if (status == HKAFFG_SEARCH_BAD_SLICE)
		{
			mid_slice_pos += slice_size - 7;
			continue;
		}

		//提示向当前片段左侧检索
		if (status == HKAFFG_SEARCH_LEFT)
		{
			if ((target_pos + mid_slice_pos) == end_frame_pos)
			{
				//说明进入死循环
				//mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
				mid_slice_pos = (end_frame_pos - start_frame_pos) / (end_frame_num - start_frame_num);
				mid_slice_pos = mid_slice_pos*(input->target_frame_num - start_frame_num) + start_frame_pos;

				//从死循环片段起始位置向前搜索最近一个结束帧
				status = HKA_STS_ERR;
				while (status != HKA_STS_OK)
				{
					//当搜索到buffer文件起始位置时, 要避免越界
					if (mid_slice_pos<(slice_size - 7))
					{
						mid_slice_pos = 0;
					}
					else
					{
						mid_slice_pos = mid_slice_pos - slice_size + 7;   //为了能够读到有效的帧号信息,在数据段切割的为需要有所重叠,避免有效数据被切割后识别失败
					}

					//当搜索片段接近于文件结束位置
					if ((file_size - mid_slice_pos)<slice_size)
					{
						slice_size = file_size - mid_slice_pos;
					}

					//如果只是要读取start_code,只需要偏3个字节,但是我们还需要frame_num 的信息,所以需要偏7个字节
					fseek(input->fp, mid_slice_pos, SEEK_SET);
					fread(spec->buffer, slice_size, 1, input->fp);
					fseek(input->fp, 0, SEEK_SET);
					status = HKAFFG_Searching_End_Group(spec->buffer, slice_size, &target_pos);

				}

				end_frame_pos = mid_slice_pos + target_pos;
				GROUP_HEADER *cur_group = (GROUP_HEADER*)(spec->buffer + target_pos);
				end_frame_num = cur_group->frame_num;

				if (cur_group->frame_num > end_frame_temp)
				{
					mid_slice_pos = mid_slice_pos - slice_size + target_pos;      //表示帧号的信息损坏时,特殊处理
					continue;
				}

				//
				if (end_frame_num > input->target_frame_num)
				{
					mid_slice_pos = (end_frame_pos - start_frame_pos)*(input->target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
					continue;
				}
				//
				if (end_frame_num == input->target_frame_num)
				{
					output->res = cur_group;
					return HKA_STS_OK;
				}
				//
				if (end_frame_num < input->target_frame_num)
				{
					return HKA_STS_ERR;
				}

			}

			end_frame_pos = (mid_slice_pos + target_pos);
			end_frame_num = cur_frame_num;
			if (cur_frame_num > end_frame_temp)
			{
				mid_slice_pos = mid_slice_pos - slice_size + target_pos;    //表示帧号的信息损坏时,特殊处理
				continue;
			}

			mid_slice_pos = (end_frame_pos - start_frame_pos) / (end_frame_num - start_frame_num);
			mid_slice_pos = mid_slice_pos*(input->target_frame_num - start_frame_num) + start_frame_pos;

		}

		/****************************************************************/
		if (status == HKAFFG_SEARCH_RIGHT)
		{
			if (start_frame_pos == mid_slice_pos + target_pos)     //每次通过比例计算的位置不再更新的时候,进入死循环
			{
				mid_slice_pos = mid_slice_pos + slice_size - 7;
				continue;
			}

			if (cur_frame_num<start_frame_temp)
			{
				mid_slice_pos = mid_slice_pos + target_pos + 4;           //当让向右查询的时候,如果cur_frame_num小于起始帧号的时候,说明信号损坏,mid_slice_pos通过偏移的实现更新
				continue;
			}

			start_frame_pos = mid_slice_pos + target_pos;
			start_frame_num = cur_frame_num;

			mid_slice_pos = (end_frame_pos - start_frame_pos) / (end_frame_num - start_frame_num);
			mid_slice_pos = mid_slice_pos*(input->target_frame_num - start_frame_num) + start_frame_pos;

		}
	}
	//344
	return HKA_STS_ERR;

}

