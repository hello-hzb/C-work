/***************************************************************************************************
* 版权信息：Copyright (c) 2015, 杭州海康威视数字技术股份有限公司
*
* 文件名称：hka_check_image.c
* 摘    要：检查输入、输出图像参数是否正确，一般在算法库内使用
*
* 当前版本：0.5.0
* 作    者：武晓阳
* 日    期：2015年05月20日
* 备    注：创建并完成草稿
***************************************************************************************************/
#include "hka_ffg.h"
#define FILE_HEADER_SIZE sizeof(HIKVISION_MEDIA_FILE_HEADER)   //40
#define GROUP_HEADER_SIZE sizeof(GROUP_HEADER)				   //48
#define BLOCK_HEADER_SIZE sizeof(BLOCK_HEADER)				   //20


//函数返回状态类型
//算法库可以在库头文件中自定义状态类型，自定义状态类型值 < -1000。
typedef enum _HKAFFG_SEARCH_CODE
{
	HKAFFG_SEARCH_LEFT = 0x1000,
	HKAFFG_STS_OK = 0x1001,
	HKAFFG_SEARCH_RIGHT = 0x1002,
	HKAFFG_SEARCH_BAD_SLICE = 0x1003

}HKAFFG_STATUS_CODE;


/***************************************************************************************************
* 功  能：暴力查找 ,输入数据以char *类型传入
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Violence(char *buffer,
	int target_frame_num,
	unsigned int file_size,
	unsigned int *return_frame_num,
	unsigned int *pos_offset)
{
	unsigned int *data_4byte;
	unsigned int len = file_size;
	unsigned int start_frame_num = 33824;
	unsigned int end_frame_num = 36387;

	GROUP_HEADER *first_group_header;
	GROUP_HEADER *end_group_header;

	unsigned int start=0;
	unsigned int end=0;

	//查找起始帧号
	for (int i = 0; i < len; i++)
	{
		data_4byte = (unsigned int *)(buffer + i);
		//printf("data_4byte is %d", *data_4byte);
		if ((*data_4byte == 0x484B4D34) || (*data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 40;
			i--;
			continue;
		}
		if (*data_4byte == 0x00000001U)												  //找到group header
		{
			first_group_header = (GROUP_HEADER *)(buffer + i);
			start_frame_num = first_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			start = i;
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = (unsigned int *)(buffer + i);
		if (*data_4byte == 0x00000001)												  //找到group header
		{
			end_group_header = (GROUP_HEADER *)(buffer + i);
			end_frame_num = end_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			end = i;
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKAFFG_SEARCH_BAD_SLICE;
	}
	if (target_frame_num < start_frame_num)
	{
		*return_frame_num = start_frame_num;
		*pos_offset = start;
		return HKAFFG_SEARCH_LEFT;
	}
	if (target_frame_num > end_frame_num)
	{
		*return_frame_num = end_frame_num;
		*pos_offset = end;
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKAFFG_SEARCH_RIGHT;
	}


	//
	GROUP_HEADER *cur_group_header;
	for (int i = 0; i < len - 4; i++)
	{
		data_4byte = (unsigned int *)(buffer + i);
		if (*data_4byte == 0x00000001U)												  //找到group header
		{
			cur_group_header = (GROUP_HEADER *)(buffer + i);                   //i为group header的地址偏移, i+4为frame num的起始地址
			//printf("Frame number is %d, start position is %d \n", frame_num, i);

			if (cur_group_header->frame_num == target_frame_num)
			{
				//printf("检索成功, 帧号为 %d\n", frame_num);
				*return_frame_num = target_frame_num;
				*pos_offset = i;
				return HKA_STS_OK;
			}

		}
	}
	return HKA_STS_ERR;
}




HKA_STATUS HKAFFG_Process_Test_V4(FILE *fp, unsigned char *buffer, int target_frame_num, GROUP_HEADER **res)
{
	if (fp == NULL)
		return HKA_STS_ERR;

	fseek(fp, 0, SEEK_END);
	unsigned int file_size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	//15ms


	unsigned int slice_size = SLICE_SIZE;  //根据L1 cache 32KB的大小设置
	unsigned int slice_num = (file_size + slice_size - 1) / slice_size;

	unsigned int start_frame_pos = -1;
	unsigned int end_frame_pos = -1;

	unsigned int target_pos = -1;

	unsigned int start_frame_num = -1;
	unsigned int end_frame_num = -1;
	unsigned int cur_frame_num;

	HKA_STATUS status = HKA_STS_ERR;
	//46ms

	if (slice_num == 1)
	{
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, file_size, &cur_frame_num, &target_pos);
		if (status == HKA_STS_OK)
		{
			*res = (GROUP_HEADER *)(buffer + target_pos);
			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//46ms

	//搜索原始文件的起始帧号
	int slice_start = 0;
	for (int i = 0; i < slice_num; i++)
	{
		if (i != 0)
		{
			slice_start = slice_size*i - 3;
		}
		fseek(fp, slice_start, SEEK_SET);                 //如果属于视频开头片段的话,从0开始切片段

		//当切割到最后一个slice时,最后一个slice中的数据可能小于slice_size的特殊处理, 避免搜索的时候出现越界
		if ((file_size - slice_start) < slice_size)
		{
			slice_size = file_size - slice_start;
		}

		fread(buffer, slice_size, 1, fp);
		status = HKAFFG_Searching_Start_Group(buffer, slice_size, &start_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *start_group_header = (GROUP_HEADER *)(buffer + start_frame_pos);
			start_frame_num = start_group_header->frame_num;
			start_frame_pos = slice_start + start_frame_pos;
			break;
		}
	}
	//如果没有搜索到起始帧号,说明原始文件中没有完整帧信息,结束函数
	if ((start_frame_num <0x00001000) || (target_frame_num<start_frame_num))
		return HKA_STS_ERR;

	if (target_frame_num == start_frame_num)
	{
		*res = (GROUP_HEADER *)(buffer + start_frame_pos);

		return HKA_STS_OK;
	}

	//63
	//搜索原始文件的结束帧号
	slice_start = slice_size;
	for (int i = 1; i <slice_num; i++)
	{

		if (i > 1)
		{
			slice_start = slice_size*i - 3;
		}

		if (slice_start > file_size)
		{
			slice_size = file_size + slice_size - slice_start;
			slice_start = file_size;
		}
		fseek(fp, -slice_start, SEEK_END);

		fread(buffer, slice_size, 1, fp);
		status = HKAFFG_Searching_End_Group(buffer, slice_size, &end_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *end_group_header = (GROUP_HEADER *)(buffer + end_frame_pos);
			end_frame_num = end_group_header->frame_num;
			end_frame_pos = file_size - slice_start + end_frame_pos;
			break;
		}
	}
	//////如果没有搜索到结束帧号,说明原始文件中没有完整帧信息,结束函数
	if ((end_frame_num <0x00001000) || (target_frame_num>end_frame_num))
		return HKA_STS_ERR;

	if (target_frame_num == end_frame_num)
	{
		*res = (GROUP_HEADER *)(buffer + start_frame_pos);

		return HKA_STS_OK;
	}


	if (end_frame_num == start_frame_num)
	{
		if (target_frame_num == start_frame_num)
		{
			*res = (GROUP_HEADER *)(buffer + start_frame_pos);

			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//109
	/**********************************************************************************************************************/
	//开始在进行slice级别的二分查找

	unsigned int start_frame_temp = start_frame_num;
	unsigned int end_frame_temp = end_frame_num;
	unsigned int mid_slice_pos;
	HKA_STATUS old_status;
	mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;

	while (1)
	{
		slice_size = SLICE_SIZE;
		fseek(fp, mid_slice_pos, SEEK_SET);
		if ((file_size - mid_slice_pos)<slice_size)
		{
			slice_size = file_size - mid_slice_pos;
		}
		fread(buffer, slice_size, 1, fp);
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, slice_size, &cur_frame_num, &target_pos);

		//对片段内的搜索结果进行处理

		//说明帧号不存在
		if (status == HKA_STS_ERR)
		{
			return HKA_STS_ERR;
		}

		//帧号搜索成功
		if (status == HKA_STS_OK)
		{
			*res = (GROUP_HEADER *)(buffer + target_pos);
			return HKA_STS_OK;
		}
		//如果数据片段内不存在帧号信息
		if (status == HKAFFG_SEARCH_BAD_SLICE)
		{
			mid_slice_pos += slice_size - 3;
			continue;
		}

		//提示向当前片段左侧检索
		if (status == HKAFFG_SEARCH_LEFT)
		{
			if ((target_pos + mid_slice_pos) == end_frame_pos)
			{
				//说明进入死循环
				mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
				//从死循环片段起始位置向前搜索最近一个结束帧
				status = HKA_STS_ERR;
				mid_slice_pos = end_frame_pos;
				while (status != HKA_STS_OK)
				{
					mid_slice_pos = mid_slice_pos - slice_size + 3;

					fseek(fp, mid_slice_pos, SEEK_SET);
					if ((file_size - mid_slice_pos)<slice_size)
					{
						slice_size = file_size - mid_slice_pos;
					}
					fread(buffer, slice_size, 1, fp);
					status = HKAFFG_Searching_End_Group(buffer, slice_size, &target_pos);

				}

				end_frame_pos = mid_slice_pos + target_pos;
				GROUP_HEADER *cur_group = (GROUP_HEADER*)(buffer + target_pos);
				end_frame_num = cur_group->frame_num;

				if (cur_group->frame_num > end_frame_temp)
				{
					mid_slice_pos = mid_slice_pos - slice_size + target_pos;      //表示帧号的信息损坏时,特殊处理
					continue;
				}

				//
				if (end_frame_num > target_frame_num)
				{
					mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
					continue;
				}
				//
				if (end_frame_num == target_frame_num)
				{
					*res = cur_group;
					return HKA_STS_OK;
				}
				//
				if (end_frame_num < target_frame_num)
				{
					return HKA_STS_ERR;
				}

			}

			end_frame_pos = (mid_slice_pos + target_pos);
			end_frame_num = cur_frame_num;
			if (cur_frame_num > end_frame_temp)
			{
				mid_slice_pos = mid_slice_pos - slice_size + target_pos;    //表示帧号的信息损坏时,特殊处理
				continue;
			}
			mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
		}

		/****************************************************************/
		if (status == HKAFFG_SEARCH_RIGHT)
		{
			if (start_frame_pos == mid_slice_pos + target_pos)     //每次通过比例计算的位置不再更新的时候,进入死循环
			{
				mid_slice_pos = mid_slice_pos + slice_size - 3;
				continue;
			}

			if ((cur_frame_num<start_frame_temp))
			{
				mid_slice_pos = mid_slice_pos + target_pos + 4;           //当让向右查询的时候,如果cur_frame_num小于起始帧号的时候,说明信号损坏,mid_slice_pos通过偏移的实现更新
				continue;
			}

			start_frame_pos = (mid_slice_pos + target_pos);
			start_frame_num = cur_frame_num;
			mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
		}
	}
	//344
	return HKA_STS_ERR;

}

HKA_STATUS HKAFFG_Process_Test_V3(FILE *fp, unsigned char *buffer, int target_frame_num, GROUP_HEADER **res)
{
	if (fp == NULL)
		return HKA_STS_ERR;

	fseek(fp, 0, SEEK_END);
	unsigned int file_size = ftell(fp);                                       
	fseek(fp, 0, SEEK_SET);
	//15ms


	unsigned int slice_size = SLICE_SIZE;  //根据L1 cache 32KB的大小设置
	unsigned int slice_num = (file_size + slice_size - 1) / slice_size;

	unsigned int start_frame_pos = -1;
	unsigned int end_frame_pos = -1;

	unsigned int target_pos = -1;

	unsigned int start_frame_num = -1;
	unsigned int end_frame_num = -1;
	unsigned int cur_frame_num;

	HKA_STATUS status = HKA_STS_ERR;
	//46ms

	if (slice_num == 1)
	{
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, file_size, &cur_frame_num, &target_pos);
		if (status == HKA_STS_OK)
		{
			*res = (GROUP_HEADER *)(buffer + target_pos);
			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//46ms

	//搜索原始文件的起始帧号
	int slice_start = 0;
	for (int i = 0; i < slice_num; i++)
	{
		if (i != 0)
		{
			slice_start = slice_size*i - 3;
		}
		fseek(fp, slice_start, SEEK_SET);                 //如果属于视频开头片段的话,从0开始切片段

		//当切割到最后一个slice时,最后一个slice中的数据可能小于slice_size的特殊处理, 避免搜索的时候出现越界
		if ((file_size - slice_start) < slice_size)
		{
			slice_size = file_size - slice_start;
		}

		fread(buffer, slice_size, 1, fp);
		status = HKAFFG_Searching_Start_Group(buffer, slice_size, &start_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *start_group_header = (GROUP_HEADER *)(buffer + start_frame_pos);
			start_frame_num = start_group_header->frame_num;
			start_frame_pos = slice_start + start_frame_pos;
			break;
		}
	}
	//如果没有搜索到起始帧号,说明原始文件中没有完整帧信息,结束函数
	if ((start_frame_num <0x00001000) || (target_frame_num<start_frame_num))
		return HKA_STS_ERR;

	if (target_frame_num == start_frame_num)
	{
		*res = (GROUP_HEADER *)(buffer + start_frame_pos);

		return HKA_STS_OK;
	}

	//63
	//搜索原始文件的结束帧号
	slice_start = slice_size;
	for (int i = 1; i <slice_num; i++)
	{
		
		if (i > 1)
		{
			slice_start = slice_size*i - 3;
		}
		
		if (slice_start > file_size)
		{
			slice_size = file_size + slice_size - slice_start;
			slice_start = file_size;
		}
		fseek(fp, -slice_start, SEEK_END);                

		fread(buffer, slice_size, 1, fp);
		status = HKAFFG_Searching_End_Group(buffer, slice_size, &end_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *end_group_header = (GROUP_HEADER *)(buffer + end_frame_pos);
			end_frame_num = end_group_header->frame_num;
			end_frame_pos = file_size - slice_start + end_frame_pos;
			break;
		}
	}
	//////如果没有搜索到结束帧号,说明原始文件中没有完整帧信息,结束函数
	if ((end_frame_num <0x00001000) || (target_frame_num>end_frame_num))
		return HKA_STS_ERR;

	if (target_frame_num == end_frame_num)
	{
		*res = (GROUP_HEADER *)(buffer + start_frame_pos);

		return HKA_STS_OK;
	}


	if (end_frame_num == start_frame_num)
	{
		if (target_frame_num == start_frame_num)
		{
			*res = (GROUP_HEADER *)(buffer + start_frame_pos);

			return HKA_STS_OK;
		}
		else
			return HKA_STS_ERR;
	}
	//109
	/**********************************************************************************************************************/
	//开始在进行slice级别的二分查找
	
	unsigned int start_frame_temp = start_frame_num;
	unsigned int end_frame_temp = end_frame_num;
	unsigned int mid_slice_pos;
	mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;

	while (1)
	{
		slice_size = SLICE_SIZE;
		fseek(fp, mid_slice_pos, SEEK_SET);
		if ((file_size - mid_slice_pos)<slice_size)
		{
			slice_size = file_size - mid_slice_pos;
		}
		fread(buffer, slice_size, 1, fp);
		//status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, slice_size, &cur_frame_num, &target_pos);
		status = HKAFFG_Violence(buffer, target_frame_num, slice_size, &cur_frame_num, &target_pos);

		//对片段内的搜索结果进行处理

		//说明帧号不存在
		if (status == HKA_STS_ERR)
		{
			return HKA_STS_ERR;
		}

		//帧号搜索成功
		if (status == HKA_STS_OK)
		{
			*res = (GROUP_HEADER *)(buffer + target_pos);
			return HKA_STS_OK;
		}
		//如果数据片段内不存在帧号信息
		if (status == HKAFFG_SEARCH_BAD_SLICE)
		{
			mid_slice_pos += slice_size-3;
			continue;
		}

		//提示向当前片段左侧检索
		if (status == HKAFFG_SEARCH_LEFT)
		{
			if ((target_pos + mid_slice_pos) == end_frame_pos)
			{
				//说明进入死循环
				mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
				//从死循环片段起始位置向前搜索最近一个结束帧
				status = HKA_STS_ERR;
				mid_slice_pos = end_frame_pos;
				while (status != HKA_STS_OK)
				{
					mid_slice_pos = mid_slice_pos - slice_size + 3;
					
					fseek(fp, mid_slice_pos, SEEK_SET);
					if ((file_size - mid_slice_pos)<slice_size)
					{
						slice_size = file_size - mid_slice_pos;
					}
					fread(buffer, slice_size, 1, fp);
					status = HKAFFG_Searching_End_Group(buffer, slice_size, &target_pos);

				}

				end_frame_pos = mid_slice_pos + target_pos;
				GROUP_HEADER *cur_group = (GROUP_HEADER*)(buffer + target_pos);
				end_frame_num = cur_group->frame_num;
				
				if (cur_group->frame_num > end_frame_temp)
				{
					mid_slice_pos = mid_slice_pos - slice_size + target_pos;      //表示帧号的信息损坏时,特殊处理
					continue;
				}

				//
				if (end_frame_num > target_frame_num)
				{
					mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
					continue;
				}
				//
				if (end_frame_num == target_frame_num)
				{
					*res = cur_group;
					return HKA_STS_OK;
				}
				//
				if (end_frame_num < target_frame_num)
				{
					return HKA_STS_ERR;
				}		
				
			}

			end_frame_pos = (mid_slice_pos + target_pos);
			end_frame_num = cur_frame_num;
			if (cur_frame_num > end_frame_temp)
			{
				mid_slice_pos = mid_slice_pos - slice_size + target_pos;    //表示帧号的信息损坏时,特殊处理
				continue;
			}
			mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
		}

		/****************************************************************/
		if (status == HKAFFG_SEARCH_RIGHT)
		{
			if (start_frame_pos == mid_slice_pos + target_pos)     //每次通过比例计算的位置不再更新的时候,进入死循环
			{
				mid_slice_pos = mid_slice_pos + slice_size - 3;
				continue;
			}

			if ((cur_frame_num<start_frame_temp))
			{
				mid_slice_pos = mid_slice_pos + target_pos+4;           //当让向右查询的时候,如果cur_frame_num小于起始帧号的时候,说明信号损坏,mid_slice_pos通过偏移的实现更新
				continue;
			}

			start_frame_pos = (mid_slice_pos + target_pos);
			start_frame_num = cur_frame_num;
			mid_slice_pos = (end_frame_pos - start_frame_pos)*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_frame_pos;
		}
	}
	//344
	return HKA_STS_ERR;

}


/*
HKA_STATUS HKAFFG_Process_Test_V2(FILE *fp, unsigned char *buffer, int target_frame_num, GROUP_HEADER *res)
{
	if (fp == NULL)
		exit(1);

	fseek(fp, 0, SEEK_END);
	unsigned int file_size = ftell(fp);                                       //file_size实际在使用的时候应该减去4, 避免出现group的start_code在最后一个字节出现,但是frame_num却不存在,完整的说应该减去48,如果group不完整,那就是不存在
	fseek(fp, 0, SEEK_SET);
	//15ms


	unsigned int slice_size = SLICE_SIZE;  //根据L1 cache 32KB的大小设置
	unsigned int slice_num = (file_size + slice_size - 1) / slice_size;

	unsigned int start_slice = 0;
	unsigned int end_slice = slice_num - 1;

	unsigned int start_frame_pos = -1;
	unsigned int end_frame_pos = -1;

	unsigned int target_pos = -1;

	unsigned int start_frame_num = -1;
	unsigned int end_frame_num = -1;

	//unsigned char *buffer = (unsigned char *)malloc(SLICE_SIZE + 3);

	//char buffer[SLICE_SIZE + 3];
	HKA_STATUS status = HKA_STS_ERR;
	//78ms

	if (slice_num == 1)
	{
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, file_size, &target_pos);
		if (status == HKA_STS_OK)
		{
			fseek(fp, target_pos, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败
			fread(res, sizeof(GROUP_HEADER), 1, fp);
			return status;
		}
		else
			return HKA_STS_ERR;
	}
	//531ms

	//搜索原始文件的起始帧号
	for (int i = 0; i < slice_num; i++)
	{
		int slice_start = 0;
		if (i != 0)
		{
			slice_start = slice_size*i - 3;
		}
		fseek(fp, slice_start, SEEK_SET);                 //如果属于视频开头片段的话,从0开始切片段


		//当切割到最后一个slice时,最后一个slice中的数据可能小于slice_size的特殊处理, 避免搜索的时候出现越界
		if ((file_size - slice_start - 3) < slice_size)
		{
			slice_size = file_size - slice_size*i;
		}

		fread(buffer, slice_size + 3, 1, fp);
		status = HKAFFG_Searching_Start_Group(buffer, slice_size + 3, &start_frame_pos);

		if (status == HKA_STS_OK)
		{
			//unsigned int *x = (unsigned int *)(buffer + start_frame_pos+4);
			GROUP_HEADER *start_group_header = (GROUP_HEADER *)(buffer + start_frame_pos);
			start_frame_num = start_group_header->frame_num;
			start_frame_pos = slice_start + start_frame_pos;
			break;
		}
	}
	//如果没有搜索到起始帧号,说明原始文件中没有完整帧信息,结束函数
	if (start_frame_num == -1)
		return HKA_STS_ERR;
	//546
	//搜索原始文件的结束帧号
	for (int i = 1; i <slice_num; i++)
	{
		int slice_start = slice_size*i + 3;
		if (slice_start > file_size)
		{
			slice_size = slice_start - file_size;
			slice_start = file_size;
		}
		fseek(fp, -slice_start, SEEK_END);               //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败

		fread(buffer, slice_size + 3, 1, fp);
		status = HKAFFG_Searching_End_Group(buffer, slice_size + 3, &end_frame_pos);

		if (status == HKA_STS_OK)
		{
			GROUP_HEADER *end_group_header = (GROUP_HEADER *)(buffer + end_frame_pos);
			end_frame_num = end_group_header->frame_num;
			end_frame_pos = file_size - slice_start + end_frame_pos;
			break;
		}
	}
	//如果没有搜索到结束帧号,说明原始文件中没有完整帧信息,结束函数
	if (end_frame_num == -1)
		return HKA_STS_ERR;

	if (end_frame_num == start_frame_num)
	{
		if (target_frame_num == start_frame_num)
			return HKA_STS_OK;
		else
			return HKA_STS_ERR;
	}

	////开始在进行slice级别的二分查找
	slice_size = SLICE_SIZE;
	unsigned int slice_num_gap;
	unsigned int mid_slice;

	while (start_slice<end_slice)
	{
		//slice_num_gap = float slice_num / (float) (end_frame_num - start_frame_num);
		mid_slice = slice_num*(target_frame_num - start_frame_num) / (end_frame_num - start_frame_num) + start_slice;

		if (mid_slice == 0)
		{
			fseek(fp, slice_size*mid_slice, SEEK_SET);
		}
		else
		{
			fseek(fp, slice_size*mid_slice - 3, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败
		}


		if ((file_size - slice_size*mid_slice) < slice_size)
		{
			slice_size = file_size - slice_size*mid_slice;
		}

		fread(buffer, slice_size + 3, 1, fp);
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, slice_size + 3, &target_pos);

		if (status == HKA_STS_OK)
		{
			if (mid_slice != 0)
			{
				target_pos += slice_size*mid_slice - 3;
			}
			fseek(fp, target_pos, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败
			fread(res, sizeof(GROUP_HEADER), 1, fp);
			return HKA_STS_OK;
		}

		if (status == HKAFFG_SEARCH_LEFT)
		{

			end_slice = mid_slice-1;
			end_frame_pos = target_pos;
			end_frame_num = (unsigned int *)(buffer + end_frame_pos + 4);
		}

		if (status == HKAFFG_SEARCH_RIGHT)
		{

			start_slice = mid_slice+1;
			start_frame_pos = target_pos;
			start_frame_num = (unsigned int *)(buffer + start_frame_pos + 4);
		}

	}
	return HKA_STS_ERR;
	//free(buffer);



}

*/


/***************************************************************************************************
* 功  能：模块功能处理函数
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
/*
HKA_STATUS HKAFFG_Process_Test(FILE *fp, unsigned char *buffer, int target_frame_num, GROUP_HEADER *res)
{
	if (fp == NULL)
		exit(1);

	fseek(fp, 0, SEEK_END);
	unsigned int file_size = ftell(fp);                                       //file_size实际在使用的时候应该减去4, 避免出现group的start_code在最后一个字节出现,但是frame_num却不存在,完整的说应该减去48,如果group不完整,那就是不存在
	fseek(fp, 0, SEEK_SET);
	//15ms


	unsigned int slice_size = SLICE_SIZE;  //根据L1 cache 32KB的大小设置
	unsigned int slice_num = (file_size+slice_size-1) / slice_size;  

	unsigned int start_slice = 0;
	unsigned int end_slice = slice_num - 1;

	unsigned int start_frame_pos = -1;
	unsigned int end_frame_pos = -1;

	unsigned int target_pos = -1;

	unsigned int start_frame_num = -1;
	unsigned int end_frame_num = -1;

	//unsigned char *buffer = (unsigned char *)malloc(SLICE_SIZE + 3);

	//char buffer[SLICE_SIZE + 3];
	HKA_STATUS status = HKA_STS_ERR;
	//78ms

	if (slice_num == 1)
	{
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, file_size, target_pos);
		if (status == HKA_STS_OK)
		{
			fseek(fp, target_pos, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败
			fread(res, sizeof(GROUP_HEADER), 1, fp);
			return status;
		}
		else
			return HKA_STS_ERR;
	}
	//531ms

	//搜索原始文件的起始帧号
	for (int i = 0; i < slice_num; i++)
	{
		int slice_start = 0;
		if (i != 0)
		{
			slice_start = slice_size*i - 3;
		}
		fseek(fp, slice_start, SEEK_SET);                 //如果属于视频开头片段的话,从0开始切片段


		//当切割到最后一个slice时,最后一个slice中的数据可能小于slice_size的特殊处理, 避免搜索的时候出现越界
		if ((file_size - slice_start-3) < slice_size)
		{
			slice_size = file_size - slice_size*i;
		}

		fread(buffer, slice_size+3, 1, fp);
		status = HKAFFG_Searching_Start_Group(buffer, slice_size + 3, &start_frame_pos);                     
		
		if (status == HKA_STS_OK)
		{
			//unsigned int *x = (unsigned int *)(buffer + start_frame_pos+4);
			start_frame_num = *(buffer + start_frame_pos + 4);
			start_frame_num = (start_frame_num<<8) + *(buffer + start_frame_pos + 3);
			start_frame_num = (start_frame_num << 8) + *(buffer + start_frame_pos + 2);
			start_frame_num = (start_frame_num << 8) + *(buffer + start_frame_pos+1);
			start_frame_pos = slice_start + start_frame_pos;
			break;
		}
	}
	//如果没有搜索到起始帧号,说明原始文件中没有完整帧信息,结束函数
	if (start_frame_num == -1)
		return HKA_STS_ERR;
	//546
	//搜索原始文件的结束帧号
	for (int i = 1; i <slice_num; i++)
	{
		int slice_start = slice_size*i+3;
		if (slice_start > file_size)
		{
			slice_size = slice_start -  file_size;
			slice_start = file_size;
		}
		fseek(fp, -slice_start, SEEK_END);               //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败

		fread(buffer, slice_size + 3, 1, fp);
		status = HKAFFG_Searching_End_Group(buffer, slice_size + 3, &end_frame_pos);

		if (status == HKA_STS_OK)
		{
			end_frame_num = *(unsigned int *)(buffer + end_frame_pos + 4);
			end_frame_pos = file_size - slice_start + end_frame_pos;
			break;
		}
	}
	//如果没有搜索到结束帧号,说明原始文件中没有完整帧信息,结束函数
	if (end_frame_num == -1)
		return HKA_STS_ERR;


	////开始在进行slice级别的二分查找
	slice_size = SLICE_SIZE;
	unsigned int slice_num_gap ;
	unsigned int mid_slice;

	while (1)
	{
		slice_num_gap = slice_num / (end_frame_num - start_frame_num);
		mid_slice = slice_num_gap*(target_frame_num - start_frame_num) + start_slice;

		fseek(fp, slice_size*mid_slice - 3, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败

		if ((file_size - slice_size*mid_slice) < slice_size)
		{
			slice_size = file_size - slice_size*mid_slice;
		}

		fread(buffer, slice_size + 3, 1, fp);
		status = HKAFFG_Process_Byte_Slice(buffer, target_frame_num, slice_size + 3, target_pos);

		if (status == HKA_STS_OK)
		{
			target_pos += slice_size*mid_slice - 3;
			fseek(fp, target_pos, SEEK_SET);   //如果不是开头,切片段的起始位置需要先前偏3个Byte位置,避免4Byte的有效数据Start_code被slice切断引起的查找失败
			fread(res, sizeof(GROUP_HEADER), 1, fp);
			return HKA_STS_OK;
		}

		if (status == HKAFFG_SEARCH_LEFT)
		{
			if (end_slice == mid_slice)
			{
				return HKA_STS_ERR;
			}
			end_slice = mid_slice;
			end_frame_pos = target_pos;
			end_frame_num = (unsigned int *)(buffer + end_frame_pos + 4);
		}

		if (status == HKAFFG_SEARCH_RIGHT)
		{
			if (start_slice == mid_slice)
			{
				return HKA_STS_ERR;
			}
			start_slice = mid_slice;
			start_frame_pos = target_pos;
			start_frame_num = (unsigned int *)(buffer + end_frame_pos + 4);
		}

	}
	//free(buffer);

	

}
*/

/***************************************************************************************************
* 功  能：查找一个数据片段中的起始帧号
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Searching_Start_Group(unsigned char *buffer, unsigned int slice_size, unsigned int *pos_offset)
{
	unsigned int data_4byte = 0;
	//查找起始帧号
	data_4byte = (data_4byte << 8) + (*(buffer + 2));
	data_4byte = (data_4byte << 8) + (*(buffer + 1));
	data_4byte = (data_4byte << 8) + (*(buffer + 0));
	data_4byte = data_4byte << 8;
	for (int i = 0; i < slice_size-3; i++)
	{
		data_4byte = ((data_4byte) >> 8) | ((*(buffer + i+3)) << 24);
		if (data_4byte == 0x00000001U)												  //找到group header
		{
			*pos_offset = i;
			return HKA_STS_OK;
		}
	}
	*pos_offset = 1;
	return HKA_STS_ERR;
}

/***************************************************************************************************
* 功  能：查找一个数据片段中的结束帧号
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Searching_End_Group(unsigned char *buffer, unsigned int slice_size, unsigned int *pos_offset)
{
	unsigned int data_4byte = 0;
	data_4byte = (data_4byte << 8) + (*(buffer + slice_size - 1));
	data_4byte = (data_4byte << 8) + (*(buffer + slice_size - 2));
	data_4byte = (data_4byte << 8) + (*(buffer + slice_size - 3));
	
	//查找结束帧号
	for (int i = slice_size - 8; i >=0; i--)
	{
		
		data_4byte = ((data_4byte) << 8) | (*(buffer + i));                           //从低位读入一个字节	 
		if (data_4byte == 0x00000001)												  //找到group header
		{
			*pos_offset = i;

			return HKA_STS_OK;
		}
	}
	*pos_offset = 1;
	return HKA_STS_ERR;
}


unsigned int HKAFFG_Combine_4Byte(unsigned char *buffer, unsigned int start_pos)
{
	unsigned int data_4byte = 0;
	data_4byte = (data_4byte << 8) + (*(buffer + start_pos+3));
	data_4byte = (data_4byte << 8) + (*(buffer + start_pos + 2));
	data_4byte = (data_4byte << 8) + (*(buffer + start_pos + 1));
	data_4byte = (data_4byte << 8) + (*(buffer + start_pos));
	return data_4byte;
}


/***************************************************************************************************
* 功  能：查找一个数据片段中是否存在目标帧号
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/

HKA_STATUS HKAFFG_Process_Byte_Slice(unsigned char *buffer,
	int target_frame_num,
	unsigned int file_size,
	unsigned int *return_frame_num,
	unsigned int *pos_offset)
{
	*pos_offset = -1;                 //初始化输出为失败时的输出
	//unsigned int *data_4byte;
	unsigned int len = file_size;
	unsigned int start_frame_num = -1;
	unsigned int end_frame_num = -1;

	GROUP_HEADER *start_group_header;
	GROUP_HEADER *end_group_header;

	unsigned int start;
	unsigned int end;

	unsigned int data_4byte = 0;

	//查找起始帧号
	HKA_STATUS status;
	status = HKAFFG_Searching_Start_Group(buffer, file_size, &start);
	if (HKA_STS_ERR == status)
	{
		*pos_offset = start;
		*return_frame_num = end_frame_num;
		return HKAFFG_SEARCH_BAD_SLICE;
	}
	start_group_header = (GROUP_HEADER *)(buffer + start);
	start_frame_num = start_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
	
	if (target_frame_num < start_frame_num)
	{
		*pos_offset = start;
		*return_frame_num = start_frame_num;
		return HKAFFG_SEARCH_LEFT;
	}

	if (target_frame_num == start_frame_num)
	{
		*pos_offset = start;
		*return_frame_num = start_frame_num;
		return HKA_STS_OK;
	}	
	
	//查找结束帧号
	status = HKAFFG_Searching_End_Group(buffer, file_size, &end);
	if (HKA_STS_ERR == status)
	{
		*pos_offset = end;
		*return_frame_num = end_frame_num;
		return HKAFFG_SEARCH_BAD_SLICE;
	}

	end_group_header = (GROUP_HEADER *)(buffer + end);
	end_frame_num = end_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
	
	if (target_frame_num > end_frame_num)
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		*pos_offset = end;
		*return_frame_num = end_frame_num;
		return HKAFFG_SEARCH_RIGHT;
	}

	if (target_frame_num == end_frame_num)
	{
		*pos_offset = end;
		*return_frame_num = end_frame_num;
		return HKA_STS_OK;
	}
	//62
	//start end 记录的是第一个group 和最后一个group的起始地址, 以下处理的就是target落在startframe和endframe的范围内了
	GROUP_HEADER *cur_group_header;
	unsigned int mid_pos = (target_frame_num - start_frame_num)*(end - start) / (end_frame_num - start_frame_num) + start;
	
	while (1)						//start 和 end 开始一直指向group header
	{

		data_4byte = HKAFFG_Combine_4Byte(buffer, mid_pos);
		while ((data_4byte != 0x00000001) && (mid_pos < (len-4)))
		{
			mid_pos++;
			data_4byte = (data_4byte >> 8) + (((unsigned int)(*(buffer + mid_pos + 3)))<<24);
		}
		if (mid_pos >= (len-4))
		{
			*return_frame_num = end_frame_num;
			return HKA_STS_ERR;
		}
		//172
		cur_group_header = (GROUP_HEADER *)(buffer + mid_pos);
		if (cur_group_header->frame_num == target_frame_num)
		{
			*pos_offset = mid_pos;
			*return_frame_num = target_frame_num;
			return HKA_STS_OK;     //搜索成功
		}

		if (cur_group_header->frame_num > target_frame_num)
		{
			//判断是否进入死循环
			if (end == mid_pos)
			{
				int j = 1;
				data_4byte = HKAFFG_Combine_4Byte(buffer, mid_pos);
				while ((mid_pos - j)>start)
				{
					data_4byte = (data_4byte << 8) + (*(buffer + mid_pos - j));

					if (data_4byte == 0x00000001)
					{
						cur_group_header = (GROUP_HEADER *)(buffer + mid_pos - j);
						if (cur_group_header->frame_num == target_frame_num)
						{
							*pos_offset = mid_pos - j;
							*return_frame_num = target_frame_num;

							return HKA_STS_OK;
						}
						if (cur_group_header->frame_num < target_frame_num)                              //这种情况说明目标虽然落在起始和结束帧号之间,但是不存在
						{
							*pos_offset = mid_pos - j;
							*return_frame_num = cur_group_header->frame_num;
							return HKA_STS_ERR;
						}
						if (cur_group_header->frame_num > target_frame_num)
						{
						}
					}
					j++;
				}
			}
			//
			end = mid_pos;
			end_frame_num = cur_group_header->frame_num;
			mid_pos = (target_frame_num - start_frame_num)*(end - start) / (end_frame_num - start_frame_num) +start;
		}

		/*********************************************************************************/
		else //目标帧号大于参考帧号, 需要向右查找
		{
			//当目标frame和检索到的frame接近时
			if (start == mid_pos)
			{
				int j = 0;
				//while ((mid_pos + j)<end)
				while (1)
				{
					

					if ((*((unsigned int*)(buffer + mid_pos + j))) == 0x00000001)
					{
						cur_group_header = (GROUP_HEADER *)(buffer + mid_pos + j);
						if (cur_group_header->frame_num == target_frame_num)
						{
							*pos_offset = mid_pos + j;
							*return_frame_num = target_frame_num;
							return HKA_STS_OK;
						}
						if (cur_group_header->frame_num > target_frame_num)            //这种情况说明目标虽然落在起始和结束帧号之间,但是不存在
						{
							*pos_offset = mid_pos + j;
							*return_frame_num = cur_group_header->frame_num;
							return HKA_STS_ERR;
						}
						if (cur_group_header->frame_num < target_frame_num)
						{
						}
					}
					j++;
				}
			}
			//当目标frame和检索到的frame较远时

			start = mid_pos;
			start_frame_num = cur_group_header->frame_num;
			mid_pos = (target_frame_num - start_frame_num)*(end - start) / (end_frame_num - start_frame_num) + start;
		}
	}
	return HKA_STS_ERR;
}

/***************************************************************************************************
* 功  能：模块功能处理函数
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Process_Byte(char *buffer,
	int target_frame_num,
	unsigned int file_size)
{
	//if (fp == NULL)
	//	exit(1);

	//fseek(fp, 0, SEEK_END);
	//unsigned int file_size = ftell(fp);
	//fseek(fp, 0, SEEK_SET);

	//char *buffer = (char *)malloc(file_size);
	//unsigned int count = fread(buffer, file_size, 1, fp);


	unsigned int *data_4byte;
	unsigned int len = file_size;
	unsigned int start_frame_num = 33824;
	unsigned int end_frame_num = 36387;

	GROUP_HEADER *first_group_header;
	GROUP_HEADER *end_group_header;

	long start = 10;
	long end = 6736069;

	//查找起始帧号
	for (int i = 0; i < len; i++)
	{
		data_4byte =  (buffer+i);
		//printf("data_4byte is %d", *data_4byte);
		if ((*data_4byte == 0x484B4D34) || (*data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 40;
			i--;
			continue;
		}
		if (*data_4byte == 0x00000001U)												  //找到group header
		{
			first_group_header = (GROUP_HEADER *)(buffer + i);
			start_frame_num = first_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			start = i;
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = (unsigned int *)(buffer + i);
		if (*data_4byte == 0x00000001)												  //找到group header
		{
			end_group_header = (GROUP_HEADER *)(buffer + i);
			end_frame_num = end_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			end = i;
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_num < start_frame_num) || (target_frame_num > end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;
	}


	if (start == end)  //如果只有一个group的情况
	{
		if (start_frame_num == target_frame_num)
		{
			return HKA_STS_OK;
		}
		else
		{
			return HKA_STS_ERR;
		}
	}

	//start end 记录的是第一个group 和最后一个group的起始地址
	GROUP_HEADER *cur_group_header;
	long gap = (end - start) / (end_frame_num - start_frame_num);
	long mid_pos = (target_frame_num - start_frame_num)*gap + start;
	long old_pos;

	while (1)						//start 和 end 开始一直指向group header
	{
		while ((*((unsigned int* )(buffer+mid_pos)) != 0x00000001) && (mid_pos < len))
		{
			mid_pos++;
		}
		if (mid_pos >= len)
		{
			return HKA_STS_ERR;
		}
		cur_group_header = (GROUP_HEADER *)(buffer + mid_pos); 
		if (cur_group_header->frame_num == target_frame_num)
		{
			return HKA_STS_OK;     //搜索成功
		}

		if (cur_group_header->frame_num > target_frame_num)
		{
			//
			if (end == mid_pos)
			{
				int j = 0;
				while (1)
				{
					if ((*((unsigned int*)(buffer + mid_pos - j))) == 0x00000001)
					{
						cur_group_header = (GROUP_HEADER *)(buffer + mid_pos-j);
						if (cur_group_header->frame_num == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (cur_group_header->frame_num < target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (cur_group_header->frame_num > target_frame_num)
						{
							//j = j + 26;
						}
					}
					j++;
				}
			}
			//
			end = mid_pos;
			end_frame_num = cur_group_header->frame_num;
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}

		/*********************************************************************************/
		else //((buffer[mid_pos + 1] < target_frame_num))
		{
			//当目标frame和检索到的frame接近时
			if (start == mid_pos)
			{
				int j = 0;
				while (1)
				{
					if (cur_group_header->frame_num == 0x00000001)
					{
						cur_group_header = (GROUP_HEADER *)(buffer + j);
						if (cur_group_header->frame_num == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (cur_group_header->frame_num > target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (cur_group_header->frame_num < target_frame_num)
						{
							//j = j + 1;
						}
					}
					j++;
				}
			}
			//当目标frame和检索到的frame较远时

			start = mid_pos;
			start_frame_num = cur_group_header->frame_num;
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}
	}
	return HKA_STS_ERR;
}

/***************************************************************************************************
* 功  能：暴力查找 ,输入数据以char *类型传入
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Get_All_Byte(char *buffer,
	int target_frame_num,
	unsigned int file_size)
{
	unsigned int *data_4byte;
	unsigned int len = file_size;
	unsigned int start_frame_num = 33824;
	unsigned int end_frame_num = 36387;

	GROUP_HEADER *first_group_header;
	GROUP_HEADER *end_group_header;

	long start = 10;
	long end = 6736069;

	//查找起始帧号
	for (int i = 0; i < len; i++)
	{
		data_4byte = (unsigned int *)(buffer + i);
		//printf("data_4byte is %d", *data_4byte);
		if ((*data_4byte == 0x484B4D34) || (*data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 40;
			i--;
			continue;
		}
		if (*data_4byte == 0x00000001U)												  //找到group header
		{
			first_group_header = (GROUP_HEADER *)(buffer + i);
			start_frame_num = first_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			start = i;
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = (unsigned int *)(buffer + i);
		if (*data_4byte == 0x00000001)												  //找到group header
		{
			end_group_header = (GROUP_HEADER *)(buffer + i);
			end_frame_num = end_group_header->frame_num;                   //i为group header的地址偏移, i+4为frame num的起始地址
			end = i;
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_num < start_frame_num) || (target_frame_num > end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;
	}


	//
	GROUP_HEADER *cur_group_header;
	for (int i = 0; i < len-4; i++)
	{
		data_4byte = (unsigned int *)(buffer+i);
		if (*data_4byte == 0x00000001U)												  //找到group header
		{
			cur_group_header = (GROUP_HEADER *)(buffer+i);                   //i为group header的地址偏移, i+4为frame num的起始地址
			//printf("Frame number is %d, start position is %d \n", frame_num, i);

			if (cur_group_header->frame_num == target_frame_num)
			{
				//printf("检索成功, 帧号为 %d\n", frame_num);
				return HKA_STS_OK;
			}

		}
	}
	return HKA_STS_ERR;
}



/***************************************************************************************************
* 功  能：暴力方法查找帧号
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：
***************************************************************************************************/
HKA_STATUS HKAFFG_Process_V5(unsigned int *buffer,
	int target_frame_number,
	long file_size)
{
	unsigned int frame_num = 0;
	unsigned int block_num = 0;
	unsigned int block_size = 0;
	unsigned int data_4byte = 0;

	long len = file_size / 4;
	unsigned int start_frame_num = 0;
	unsigned int end_frame_num = 0;

	//查找起始帧号
	for (int i = 0; i < len - 1; i++)
	{
		data_4byte = buffer[i];
		if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + FILE_HEADER_SIZE;
			i--;
			continue;
		}
		if (data_4byte == 0x00000001U)												  //找到group header
		{
			start_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = buffer[i];
		//if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		//{
		//	i = i + FILE_HEADER_SIZE;
		//	i--;
		//	continue;
		//}

		if (data_4byte == 0x00000001U)												  //找到group header
		{
			end_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_number<start_frame_num) || (target_frame_number>end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;

	}

	//

	for (int i = 0; i < len; i++)
	{
		data_4byte = buffer[i];
		if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 10;
			i--;

			continue;
		}
		if (data_4byte == 0x00000001U)												  //找到group header
		{

			frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			//printf("Frame number is %d, start position is %d \n", frame_num, i);

			if (frame_num == target_frame_number)
			{
				//printf("检索成功, 帧号为 %d\n", frame_num);
				return HKA_STS_OK;
			}

			block_num = buffer[i + 4] - 0x00001000;    //i为group header的地址偏移, i+16为block_num数据的地址起始位置

			for (int j = 0; j < block_num; j++)
			{
				i = i + 12;										   //跳到block header地址
				block_size = buffer[i + 4];                        //获得当前block data的大小
				i = i + 5 + block_size / 4;                          //i增大,跳过block header和block data的地址段
			}
			i--;																 //由于for循环本身会自加,在检测到 file header或者group header后会做i的更新,此时for循环的i++会多于,故此处减1
		}
	}
	return HKA_STS_ERR;
}

/***************************************************************************************************
* 功  能：二分查找法进行group查找
* 参  数：*
*         size        -I    所需分配的内存大小
*         align       -I    对齐的字节数，需要为2的幂次方
* 返回值：所分配内存指针
* 备  注：有问题,可能存在在一段没有group header的数据段中搜索,这样就会死循环了
***************************************************************************************************/
//HKA_STATUS HKAFFG_Process_V6(unsigned int *buffer,
//	int target_frame_number,
//	long file_size)
//{
//	unsigned int frame_num = 0;
//	unsigned int block_num = 0;
//	unsigned int block_size = 0;
//	unsigned int data_4byte = 0;
//
//	long len = file_size / 4;
//	long start = 0;
//	long end = len - 1;
//
//	unsigned int start_frame_num = 0;
//	unsigned int end_frame_num = 0;
//
//
//
//	//查找起始帧号
//	for (int i = 0; i < len; i++)
//	{
//		data_4byte = buffer[i];
//		if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
//		{
//			i = i + 10;
//			i--;
//			continue;
//		}
//		if (data_4byte == 0x00000001U)												  //找到group header
//		{
//			start_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
//			start = i;
//			break;
//		}
//	}
//
//	//查找结束帧号
//	for (int i = len - 1; i >= 0; i--)
//	{
//		data_4byte = buffer[i];
//		if (data_4byte == 0x00000001U)												  //找到group header
//		{
//			end_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
//			end = i;
//			break;
//		}
//	}
//
//	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
//	if ((start_frame_num == 0) || (end_frame_num == 0))
//	{
//		return HKA_STS_ERR;
//	}
//	if ((target_frame_number<start_frame_num) || (target_frame_number>end_frame_num))
//	{
//		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
//		return HKA_STS_ERR;
//	}
//
//
//
//	while (start <= end)
//	{
//		//printf("%d\n", end - start);
//		//每次从内存片段后半段查找第一个group
//		long mid = (start + end) / 2;
//
//		for (int i = mid; i <= end; i++)
//		{
//			data_4byte = buffer[i];
//			if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
//			{
//				i = i + 10;
//				i--;
//				continue;
//			}
//
//			if (data_4byte == 0x00000001U)												  //找到group header
//			{
//				frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
//				if (frame_num == target_frame_number)
//				{
//					printf("检索成功, 帧号为 %d\n", frame_num);
//					return HKA_STS_OK;
//				}
//
//				if (frame_num > target_frame_number)
//				{
//					end = mid;
//					break;
//				}
//
//				if (frame_num < target_frame_number)
//				{
//					start = i + 1;
//					break;
//				}
//			}
//		}
//	}
//	return HKA_STS_OK;
//}
//


/***************************************************************************************************
* 功  能：二分查找法进行group查找
* 参  数：*
*         size        -I    所需分配的内存大小
*         align       -I    对齐的字节数，需要为2的幂次方
* 返回值：所分配内存指针
* 备  注：在进行二分查找的时候,为避免mid_pos不再更新,当搜索到的帧号和目标帧号差距在一定范围内时,开始暴力查找
		  这种方法有缺陷
***************************************************************************************************/
HKA_STATUS HKAFFG_Process_V7(unsigned int *buffer,
	int target_frame_num,
	long file_size)
{
	unsigned int data_4byte = 0;

	long len = file_size / 4;
	int start_frame_num = 33824;
	int end_frame_num = 36387;

	long start = 10;
	long end = 6736069;


	//查找起始帧号
	for (int i = 0; i < len; i++)
	{
		data_4byte = buffer[i];
		if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 10;
			i--;
			continue;
		}
		if (data_4byte == 0x00000001U)												  //找到group header
		{
			start_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			start = i;
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = buffer[i];
		if (data_4byte == 0x00000001)												  //找到group header
		{
			end_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			end = i;
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_num < start_frame_num) || (target_frame_num > end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;
	}


	if (start == end)  //如果只有一个group的情况
	{
		if (start_frame_num == target_frame_num)
		{
			return HKA_STS_OK;
		}
		else
		{
			return HKA_STS_ERR;
		}
	}

	//start end 记录的是第一个group 和最后一个group的起始地址

	long gap = (end - start) / (end_frame_num - start_frame_num);
	long mid_pos = (target_frame_num - start_frame_num)*gap + start;
	long old_pos;

	while (1)						//start 和 end 开始一直指向group header
	{
		while ((buffer[mid_pos] != 0x00000001) && (mid_pos < len))
		{
			mid_pos++;
		}
		if (mid_pos >= len)
		{
			return HKA_STS_ERR;
		}

		if (buffer[mid_pos + 1] == target_frame_num)
		{
			return HKA_STS_OK;     //搜索成功
		}

		if (buffer[mid_pos + 1] > target_frame_num)
		{
			//
			if ((buffer[mid_pos + 1] - target_frame_num) < 20)
			{
				int j = 0;
				while (1)
				{
					if (buffer[mid_pos - j] == 0x00000001)
					{
						if (buffer[mid_pos - j + 1] == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (buffer[mid_pos - j + 1] < target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (buffer[mid_pos - j + 1] > target_frame_num)
						{
							j = j + 26;
						}
					}
					j++;
				}
			}
			//
			end = mid_pos;
			end_frame_num = buffer[end + 1];
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}

		/*********************************************************************************/
		else  // ((buffer[mid_pos + 1] < target_frame_num))
		{
			//当目标frame和检索到的frame接近时
			if ((target_frame_num - buffer[mid_pos + 1]) < 20)
			{
				int j = 0;
				while (1)
				{
					if (buffer[mid_pos + j] == 0x00000001)
					{
						if (buffer[mid_pos + j + 1] == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (buffer[mid_pos + j + 1] > target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (buffer[mid_pos + j + 1] < target_frame_num)
						{
							j = j + 1;
						}
					}
					j++;
				}
			}
			//当目标frame和检索到的frame较远时
			start = mid_pos;
			start_frame_num = buffer[start + 1];
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}


	}
	return HKA_STS_ERR;
}



/***************************************************************************************************
* 功  能：模块功能处理函数
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：对开始暴力查找的判断条件进行修改,当mid_pos不再更新的时候开始暴力查找,功能更为准确
***************************************************************************************************/
HKA_STATUS HKAFFG_Get_All(unsigned char *buffer,
	int target_frame_number,
	unsigned int file_size,
	GROUP_HEADER **res)
{
	unsigned int frame_num = 0;
	unsigned int block_num = 0;
	unsigned int block_size = 0;
	unsigned int data_4byte = 0;

	long len = file_size;
	unsigned int start_frame_num = 0;
	unsigned int end_frame_num = 0;

	//查找起始帧号
	data_4byte = data_4byte << 8 + *(buffer + 2);
	data_4byte = data_4byte << 8 + *(buffer + 1);
	data_4byte = data_4byte << 8 + *(buffer + 0);

	for (int i = 0; i < len - 1; i++)
	{
		data_4byte = HKAFFG_Combine_4Byte(buffer, i);

		if (data_4byte == 0x00000001U)												  //找到group header
		{
			start_frame_num = HKAFFG_Combine_4Byte(buffer, i+4);                   //i为group header的地址偏移, i+4为frame num的起始地址
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 8; i >= 0; i--)
	{
		data_4byte = HKAFFG_Combine_4Byte(buffer, i);
		if (data_4byte == 0x00000001U)												  //找到group header
		{
			end_frame_num = HKAFFG_Combine_4Byte(buffer, i + 4);                   //i为group header的地址偏移, i+4为frame num的起始地址
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_number<start_frame_num) || (target_frame_number>end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;

	}

	//

	for (int i = 0; i < len; i++)
	{
		data_4byte = HKAFFG_Combine_4Byte(buffer, i);

		if (data_4byte == 0x00000001U)												  //找到group header
		{

			frame_num = HKAFFG_Combine_4Byte(buffer, i + 4);                   //i为group header的地址偏移, i+4为frame num的起始地址
			//printf("Frame number is %d, start position is %d \n", frame_num, i);

			if (frame_num == target_frame_number)
			{
				*res = (GROUP_HEADER *)(buffer + i);
				//printf("检索成功, 帧号为 %d\n", frame_num);
				return HKA_STS_OK;
			}

		}
	}
	return HKA_STS_ERR;
}


/***************************************************************************************************
* 功  能：二分查找方法,输入数据以unsigned int *类型传入
* 参  数：*
*         src_img       -I         源图像数据
*         src_step      -I         源图像行间距
*         dst_img       -O         目标图像数据
*         dst_step      -I         目标图像行间距
*         img_size      -I         图像宽高（源、目标）
*         algo_pm       -I         算法控制参数，有效范围[10, 100]
*         work_buf      -I         工作内存
* 返回值：状态码
* 备  注：对开始暴力查找的判断条件进行修改,当mid_pos不再更新的时候开始暴力查找,功能更为准确
***************************************************************************************************/
HKA_STATUS HKAFFG_Process_V8(unsigned int *buffer,
	int target_frame_num,
	long file_size)
{
	unsigned int data_4byte = 0;

	long len = file_size / 4;
	int start_frame_num = 33824;
	int end_frame_num = 36387;

	long start = 10;
	long end = 6736069;


	//查找起始帧号
	for (int i = 0; i < len; i++)
	{
		data_4byte = buffer[i];
		if ((data_4byte == 0x484B4D34) || (data_4byte == 0x484B4834))					  //找到file header中的第一个成员
		{
			i = i + 10;
			i--;
			continue;
		}
		if (data_4byte == 0x00000001U)												  //找到group header
		{
			start_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			start = i;
			break;
		}
	}

	//查找结束帧号
	for (int i = len - 1; i >= 0; i--)
	{
		data_4byte = buffer[i];
		if (data_4byte == 0x00000001)												  //找到group header
		{
			end_frame_num = buffer[i + 1];                   //i为group header的地址偏移, i+4为frame num的起始地址
			end = i;
			break;
		}
	}

	//获得首尾帧号结果判断,实际情况下帧号会加上base值0x00001000,所以首尾帧号如果还是0的话,说明获得失败
	if ((start_frame_num == 0) || (end_frame_num == 0))
	{
		return HKA_STS_ERR;
	}
	if ((target_frame_num < start_frame_num) || (target_frame_num > end_frame_num))
	{
		//printf("Target frame number is invalid, the frame number is from %d to %d. \n", start_frame_num, end_frame_num);
		return HKA_STS_ERR;
	}


	if (start == end)  //如果只有一个group的情况
	{
		if (start_frame_num == target_frame_num)
		{
			return HKA_STS_OK;
		}
		else
		{
			return HKA_STS_ERR;
		}
	}

	//start end 记录的是第一个group 和最后一个group的起始地址

	long gap = (end - start) / (end_frame_num - start_frame_num);
	long mid_pos = (target_frame_num - start_frame_num)*gap + start;
	long old_pos;

	while (1)						//start 和 end 开始一直指向group header
	{
		while ((buffer[mid_pos] != 0x00000001) && (mid_pos < len))
		{
			mid_pos++;
		}
		if (mid_pos >= len)
		{
			return HKA_STS_ERR;
		}

		if (buffer[mid_pos + 1] == target_frame_num)
		{
			return HKA_STS_OK;     //搜索成功
		}

		if (buffer[mid_pos + 1] > target_frame_num)
		{
			//
			if (end == mid_pos)
			{
				int j = 0;
				while (1)
				{
					if (buffer[mid_pos - j] == 0x00000001)
					{
						if (buffer[mid_pos - j + 1] == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (buffer[mid_pos - j + 1] < target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (buffer[mid_pos - j + 1] > target_frame_num)
						{
							//j = j + 26;
						}
					}
					j++;
				}
			}
			//
			end = mid_pos;
			end_frame_num = buffer[end + 1];
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}

		/*********************************************************************************/
		else //((buffer[mid_pos + 1] < target_frame_num))
		{
			//当目标frame和检索到的frame接近时
			if (start == mid_pos)
			{
				int j = 0;
				while (1)
				{
					if (buffer[mid_pos + j] == 0x00000001)
					{
						if (buffer[mid_pos + j + 1] == target_frame_num)
						{
							return HKA_STS_OK;
						}
						if (buffer[mid_pos + j + 1] > target_frame_num)
						{
							return HKA_STS_ERR;
						}
						if (buffer[mid_pos + j + 1] < target_frame_num)
						{
							//j = j + 1;
						}
					}
					j++;
				}
			}
			//当目标frame和检索到的frame较远时

			start = mid_pos;
			start_frame_num = buffer[start + 1];
			gap = (end - start) / (end_frame_num - start_frame_num);
			mid_pos = (target_frame_num - start_frame_num)*gap + start;
		}


	}
	return HKA_STS_ERR;
}

