/*************************************************************************************
内存泄漏的概念
内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，
造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
**************************************************************************************/

/*************************************************************************************
申请二维内存空间和释放二维内存空间


**************************************************************************************/




/***************************************************************************************
void *malloc(size_t size);
备注：void* 表示未确定类型的指针，void *可以指向任何类型的数据，
更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据
（比如是char还是int或者其他数据类型）。

所以常常在malloc前面加上类型转换如

int *data = (int *)malloc(size_t);
***************************************************************************************/


/**************************************************************************************
void *calloc(size_t n, size_t size)；
功 能： 在内存的动态存储区中分配n个长度为size的连续空间，
函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。
与malloc的区别：
calloc在动态分配完内存后，自动初始化该内存空间为零，而malloc不初始化，里边数据是随机的垃圾数据。
**************************************************************************************/
int main()
{
    char*str = NULL;
 
    /*分配内存空间*/
    str = (char*)calloc(10,sizeof(char));
 
    /*将hello写入*/
    strcpy(str, "Hello");
 
    /*显示变量内容*/
    printf("String is %s\n",str);
 
    /*释放空间*/
    free(str);
    return 0;
	
/****************************************************************************************
realloc原型是extern void *realloc(void *mem_address, unsigned int newsize);
对已经申请的内存进行重新分配
指针名=（数据类型*）realloc（要改变内存大小的指针名，新的大小）。
新的大小可大可小（如果新的大小大于原内存大小，则新分配部分不会被初始化；
如果新的大小小于原内存大小，可能会导致数据丢失 [1-2]
****************************************************************************************/
int main()
{
	inti;
	int*pn=(int*)malloc(5*sizeof(int));
	if (!pn) {
		printf("malloc fail\n");
		exit(-1);
	}
	printf("malloc%p\n",pn);
	for(i=0;i<5;i++)
	pn[i]=i;
	pn=(int*)realloc(pn,10*sizeof(int));
	if (!pn) {
		printf("realloc fail\n");
		exit(-1);
	}
	printf("realloc%p\n",pn);
	for(i=5;i<10;i++)
	pn[i]=i;
	for(i=0;i<10;i++)
	printf("%3d",pn[i]);
	free(pn);
	pn = NULL;
	return 0;
}

//几种情况：
1.重新设定的内存大小小于之前申请的内存大小，不要的内存部分数据丢失，该部分内存退还给栈；
2.重新设定的内存大小大于之前申请的内存大小，如果原来申请的内存后面有足够空间，则直接将后续空间补上；
若原内存空间中没有足够的空间，则会到其他空间寻找足够大的连续内存空间，然后将原来的数据搬运到新的够大的连续空间中去。


/**************************************************************************************
_alloca，内存分配函数，与malloc,calloc,realloc类似·，
但是注意一个重要的区别，_alloca是在栈(stack)上申请空间，用完马上就释放。

能够自动释放空间；
建议少用
**************************************************************************************/


/******************************************************************************************************************
memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中。
函数原型
void *memcpy(void *dest, const void *src, size_t n);

说明
1.source和destin所指的内存区域可能重叠，但是如果source和destin所指的内存区域重叠,那么这个函数并
不能够确保source所在重叠区域在拷贝之前不被覆盖。而使用memmove可以用来处理重叠区域。函数返回指向destin的指针.
2.如果目标数组destin本身已有数据，执行memcpy()后，将覆盖原有数据（最多覆盖n）。如果要追加数据，则每次执行memcpy后，
要将目标数组地址增加到你要追加数据的地址。
注意：source和destin都不一定是数组，任意的可读写的空间均可。
********************************************************************************************************************/
int main(void)
{
    char src[]="******************************";
    char dest[]="abcdefghijlkmnopqrstuvwxyz0123as6";
    printf("destination before memcpy:%s\n",dest);
    memcpy(dest,src,strlen(src));
    printf("destination after memcpy:%s\n",dest);
    return 0;
}


/***************************************************************************************
memcmp是比较内存区域buf1和buf2的前count个字节。该函数是按字节比较的。
返回值:
		当buf1<buf2时，返回值小于0
		当buf1==buf2时，返回值=0
		当buf1>buf2时，返回值大于0

***************************************************************************************/
#include<string.h>
#include<stdio.h>
int main()
{
	char *s1 = "Hello,Programmers!";
	char *s2 = "Hello,Programmers!";
	int r;
	r = memcmp(s1,s2,strlen(s1));
	if(!r)
		printf("s1 and s2 are identical\n");/*s1等于s2*/
	elseif(r<0)
		printf("s1 is less than s2\n");/*s1小于s2*/
	else
		printf("s1 is greater than s2\n");/*s1大于s2*/
	return 0;
}
 
// 输出结果：
// S1 AND S2 ARE IDENTICAL
// 请按任意键继续...
